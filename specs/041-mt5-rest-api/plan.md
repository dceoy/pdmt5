# Implementation Plan: REST API for MetaTrader 5 Data Access

**Branch**: `041-mt5-rest-api` | **Date**: 2026-01-02 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/041-mt5-rest-api/spec.md`

## Summary

Create a FastAPI-based REST API that exposes all read-only functionality from the `Mt5DataClient` class, enabling remote access to MetaTrader 5 market data, account information, and trading history. The API will support both JSON and Apache Parquet response formats, with content negotiation via Accept headers or query parameters. This implementation follows a read-only approach for security, excluding trading operations in the initial version.

**Technical Approach**:

- Use FastAPI framework for high-performance async HTTP server with automatic OpenAPI documentation
- Implement singleton pattern for Mt5DataClient to prevent multiple terminal connections
- Create FastAPI dependency injection for format negotiation (JSON/Parquet)
- Use pydantic models for request validation and response serialization
- Implement middleware for error handling, logging, and authentication
- Deploy as standalone Windows service that runs alongside MT5 terminal

## Technical Context

**Language/Version**: Python 3.11+ (matching existing pdmt5 project)
**Primary Dependencies**:

- FastAPI 0.109+ (async web framework with OpenAPI)
- uvicorn[standard] (ASGI server)
- pydantic 2.0+ (already used in pdmt5)
- pandas (already used in pdmt5)
- pyarrow 14.0+ (Apache Parquet support)
- python-multipart (form data handling)
- python-jose[cryptography] (JWT token authentication)
- passlib[bcrypt] (password hashing for API keys)

**Storage**: N/A (stateless API, all data from MT5 terminal in real-time)
**Testing**: pytest, pytest-asyncio, httpx (async test client for FastAPI)
**Target Platform**: Windows 10/11 (MetaTrader5 API limitation)
**Project Type**: Single web API service (no frontend, pure REST API)
**Performance Goals**:

- Health check response <500ms
- Market data queries <2s for typical datasets (<1000 records)
- Support 100 concurrent requests without degradation
- Parquet compression achieving 50-80% size reduction vs JSON

**Constraints**:

- Windows-only deployment (MT5 limitation)
- Must run on same machine as MT5 terminal (local socket connection)
- Read-only operations only (no trading)
- Singleton MT5 connection (cannot have multiple terminal instances)
- Must maintain compatibility with existing pdmt5 library

**Scale/Scope**:

- 15-20 REST endpoints covering all Mt5DataClient read methods
- Support for 100+ concurrent API consumers
- Dataset sizes from single records to 100k+ ticks/candles
- Deployed as single-instance service (one API per MT5 terminal)

## Constitution Check

_GATE: Constitution file not yet defined for this project. Skipping constitution check._

**Note**: Project should consider establishing constitution covering:

- TDD requirements
- Code quality standards (already enforced via ruff, pyright, pytest)
- Deployment practices
- API versioning policy

## Project Structure

### Documentation (this feature)

```text
specs/041-mt5-rest-api/
├── plan.md              # This file
├── research.md          # Phase 0 - technical decisions and research
├── data-model.md        # Phase 1 - request/response models
├── quickstart.md        # Phase 1 - API usage guide and examples
├── contracts/           # Phase 1 - OpenAPI specification
│   └── openapi.yaml     # Generated OpenAPI 3.1 spec
└── tasks.md             # Phase 2 - generated by speckit-tasks
```

### Source Code (repository root)

```text
pdmt5/
├── __init__.py          # Update with new exports if needed
├── mt5.py               # Existing MT5 client
├── dataframe.py         # Existing data client (unchanged)
├── trading.py           # Existing trading client (unchanged)
├── utils.py             # Existing utilities (unchanged)
└── api/                 # NEW: FastAPI application
    ├── __init__.py      # Package initialization
    ├── main.py          # FastAPI app instance, lifespan, startup/shutdown
    ├── dependencies.py  # DI: MT5 client singleton, format negotiation
    ├── models.py        # Pydantic request/response models
    ├── middleware.py    # Error handling, logging, CORS
    ├── auth.py          # Authentication (API key validation)
    ├── formatters.py    # JSON/Parquet response conversion
    └── routers/         # REST endpoint routers
        ├── __init__.py
        ├── health.py    # Health check, version endpoints
        ├── symbols.py   # Symbol information endpoints
        ├── market.py    # Market data, ticks, rates endpoints
        ├── account.py   # Account and terminal info endpoints
        └── history.py   # Orders, deals, positions history endpoints

tests/
├── test_init.py         # Existing
├── test_mt5.py          # Existing
├── test_dataframe.py    # Existing
├── test_trading.py      # Existing
├── test_utils.py        # Existing
└── test_api/            # NEW: API tests
    ├── __init__.py
    ├── conftest.py      # Shared fixtures (test client, mock MT5)
    ├── test_health.py   # Health endpoint tests
    ├── test_symbols.py  # Symbol endpoint tests
    ├── test_market.py   # Market data endpoint tests
    ├── test_account.py  # Account endpoint tests
    ├── test_history.py  # History endpoint tests
    ├── test_formatters.py  # Format conversion tests
    ├── test_auth.py     # Authentication tests
    └── test_integration.py  # End-to-end API tests

docs/
└── api/
    └── rest-api.md      # NEW: REST API documentation

pyproject.toml           # Update dependencies
README.md                # Update with API section
```

**Structure Decision**: Single project structure chosen since this is a library extension. The API module (`pdmt5/api/`) is added as a new subpackage within the existing pdmt5 library, keeping all MT5-related functionality together. This allows users to import the API components or run the API server separately while maintaining the existing library interface.

## Complexity Tracking

N/A - No constitution violations. Implementation follows standard REST API patterns with FastAPI.

---

## Phase 0: Research & Technical Decisions

### Research Questions

1. **FastAPI vs Alternative Frameworks**: Why FastAPI over Flask, Django REST, or other Python web frameworks?
2. **Parquet Implementation**: Which library (pyarrow vs fastparquet) for Parquet support?
3. **Authentication Strategy**: API key vs JWT vs OAuth2 for initial implementation?
4. **MT5 Client Lifecycle**: How to manage Mt5DataClient singleton across async requests?
5. **Content Negotiation**: Accept header vs query parameter for format selection?
6. **Async vs Sync**: Should MT5 calls be sync or wrapped in async executor?
7. **Rate Limiting**: Which approach for preventing API abuse?
8. **Error Response Format**: RFC 7807 Problem Details vs custom error format?

### Research Approach

For each question, research will:

- Review official documentation and best practices
- Examine FastAPI examples and production patterns
- Consider performance implications
- Evaluate security trade-offs
- Document decision rationale in `research.md`

---

## Phase 1: Design Artifacts

### 1. Data Model (`data-model.md`)

Will define:

- **Request Models**: Pydantic models for all endpoint parameters
  - `SymbolRequest`: symbol, group filters
  - `RatesRequest`: symbol, timeframe, date_from, date_to, count
  - `TicksRequest`: symbol, date_from, date_to, count, flags
  - `HistoryRequest`: date_from, date_to, symbol, group, ticket, position
  - `FormatPreference`: format enum (json, parquet)

- **Response Models**: Pydantic models for API responses
  - `SymbolInfo`: symbol metadata fields
  - `TickData`: tick information
  - `RateData`: OHLCV candle data
  - `AccountInfo`: account details
  - `TerminalInfo`: terminal status
  - `ErrorResponse`: error details (code, message, detail)
  - `HealthResponse`: API health status

- **Model Relationships**: How requests map to Mt5DataClient methods

### 2. API Contracts (`contracts/openapi.yaml`)

Will generate OpenAPI 3.1 specification including:

- All REST endpoints with HTTP methods (GET primarily)
- Request parameters (path, query, headers)
- Response schemas for 200, 400, 404, 500, 503 status codes
- Authentication security schemes (API key)
- Example requests and responses
- Data type definitions matching pydantic models
- Content negotiation for JSON/Parquet formats

### 3. Quickstart Guide (`quickstart.md`)

Will document:

- **Installation**: `pip install pdmt5[api]` (with optional API dependencies)
- **Configuration**: Environment variables for API keys, MT5 connection
- **Running the API**: `uvicorn pdmt5.api.main:app --host 0.0.0.0 --port 8000`
- **Example Requests**: curl/httpie examples for each endpoint
- **Format Selection**: How to request JSON vs Parquet responses
- **Authentication**: How to use API keys
- **Testing**: How to run test suite
- **Troubleshooting**: Common issues (MT5 not connected, auth failures)

### 4. Agent Context Update

Will run `.specify/scripts/bash/update-agent-context.sh claude` to add:

- FastAPI web framework knowledge
- Apache Parquet format handling
- REST API design patterns
- Async Python programming considerations
- API authentication patterns
- OpenAPI documentation generation

---

## Implementation Strategy

### Development Phases

**Phase 1: Core Infrastructure (P1)**

1. Setup FastAPI application structure
2. Implement MT5 client singleton dependency
3. Create health check endpoint
4. Implement basic error handling middleware
5. Setup pytest with async test client

**Phase 2: Format Support (P1)**

1. Implement JSON response formatter (default)
2. Implement Parquet response formatter
3. Create format negotiation dependency
4. Add content-type headers
5. Test both format conversions

**Phase 3: Market Data Endpoints (P1)**

1. Symbols list endpoint (GET /api/v1/symbols)
2. Symbol info endpoint (GET /api/v1/symbols/{symbol})
3. Symbol tick endpoint (GET /api/v1/symbols/{symbol}/tick)
4. Rates endpoints (GET /api/v1/rates/from, /from-pos, /range)
5. Ticks endpoints (GET /api/v1/ticks/from, /range)

**Phase 4: Account & Terminal (P2)**

1. Account info endpoint (GET /api/v1/account)
2. Terminal info endpoint (GET /api/v1/terminal)
3. Version endpoint (GET /api/v1/version)
4. Market book endpoint (GET /api/v1/market-book/{symbol})

**Phase 5: History & Positions (P2)**

1. Current positions endpoint (GET /api/v1/positions)
2. Current orders endpoint (GET /api/v1/orders)
3. Historical orders endpoint (GET /api/v1/history/orders)
4. Historical deals endpoint (GET /api/v1/history/deals)

**Phase 6: Security & Production (P3)**

1. Implement API key authentication
2. Add rate limiting middleware
3. Configure CORS if needed
4. Production logging configuration
5. Deployment documentation

### Testing Strategy

**Unit Tests**:

- Test each formatter (JSON, Parquet) independently
- Test pydantic model validation
- Test error handlers
- Test authentication logic

**Integration Tests**:

- Mock Mt5DataClient responses
- Test full request/response cycle
- Test format negotiation
- Test error scenarios (MT5 disconnected, invalid symbols)
- Test authentication flows

**Contract Tests**:

- Validate OpenAPI spec matches actual endpoints
- Test all status codes documented
- Verify response schemas match models

**Manual Testing**:

- Test against live MT5 terminal
- Verify Parquet file downloads correctly
- Test concurrent request handling
- Performance testing with large datasets

### Deployment Considerations

1. **Windows Service**: Package API as Windows service for auto-start
2. **Environment Configuration**: Use .env file for sensitive config
3. **Logging**: Structured logging to file for production debugging
4. **Monitoring**: Health check endpoint for uptime monitoring
5. **Documentation**: Swagger UI at /docs, ReDoc at /redoc
6. **Reverse Proxy**: Optional nginx/caddy for HTTPS termination

### Security Considerations

1. **Authentication**: Implement before exposing to network
2. **Rate Limiting**: Protect MT5 terminal from request flooding
3. **Input Validation**: Strict pydantic validation on all inputs
4. **Error Messages**: Don't leak system information in errors
5. **HTTPS**: Required for production (self-signed cert acceptable for internal use)
6. **CORS**: Restrict origins if serving browser clients

### Migration & Compatibility

- No breaking changes to existing pdmt5 library
- API is additive feature (optional installation via extras)
- Existing code using Mt5DataClient continues working unchanged
- API can be installed separately: `pip install pdmt5[api]`

### Performance Optimizations

1. **Connection Pooling**: Singleton Mt5DataClient reduces connection overhead
2. **Async Operations**: Use async/await for concurrent request handling
3. **Streaming Responses**: Consider streaming for very large datasets
4. **Compression**: Parquet format provides automatic compression
5. **Caching**: Consider caching symbol info (changes infrequently)

### Open Questions for Phase 0 Research

- Should we support async MT5 operations or use sync with thread pool?
- What's the optimal default rate limit (requests per minute)?
- Should Parquet responses stream or buffer in memory?
- Do we need pagination for large result sets?
- Should API version be in URL path (/v1/) or header?

---

## Next Steps

1. ✅ Complete Phase 0: Generate `research.md` with detailed technical decisions
2. ✅ Complete Phase 1: Generate `data-model.md`, `contracts/openapi.yaml`, `quickstart.md`
3. ⏳ Run `speckit-tasks` to break plan into actionable implementation tasks
4. ⏳ Run `speckit-implement` to execute tasks with TDD approach

## Success Criteria

Implementation will be considered complete when:

- ✅ All 15+ Mt5DataClient read methods exposed as REST endpoints
- ✅ JSON and Parquet formats both functional with automatic content negotiation
- ✅ Comprehensive test suite with >90% coverage
- ✅ OpenAPI documentation auto-generated and accessible at /docs
- ✅ Authentication mechanism prevents unauthorized access
- ✅ API handles MT5 disconnection gracefully (503 errors)
- ✅ Performance goals met (health check <500ms, concurrent requests supported)
- ✅ Production deployment guide completed
- ✅ All quality checks pass (ruff format, ruff check, pyright, pytest)
